"""
Some graph helpers for the Networkx module.

It can be used to load the flow-shop problem graphs generated by the fms-scheduler.
"""
import re
from collections import defaultdict
from collections.abc import Iterable
from pathlib import Path
from typing import Any, NamedTuple, Optional, TypeAlias, cast

import networkx as nx

OPERATIONS = re.compile(r"[\w\"' \\]*(\d+), *(\d+)[\w\"' \\]*")
POSITIONS = re.compile(r"[\w\"' \\]*(-?\d+), *(-?\d+)[\w\"' \\]*")
Edge: TypeAlias = tuple[Any, Any]


class Point(NamedTuple):
    x: float
    y: float


def parse_operations(graph: nx.Graph) -> nx.Graph:
    attributes = {}
    max_job_id = 0
    max_operation_id = 0
    for k, v in graph.nodes(data=True):
        if v is None:
            raise ValueError("Graph has no attributes")
        v["label"] = v["label"].replace('"', "")
        v["pos"] = v["pos"].replace('"', "")
        m = OPERATIONS.match(v["label"])

        if m is None:
            raise ValueError("Invalid label")

        job_id = int(m.group(1))
        operation_id = int(m.group(2))
        max_job_id = max(max_job_id, job_id)
        max_operation_id = max(max_operation_id, operation_id)

        attributes[k] = {
            "job": job_id,
            "op": operation_id,
        }

    nx.set_node_attributes(graph, attributes)
    return graph


def parse_positions(graph: nx.Graph) -> tuple[dict[Any, tuple[float, float]], Point, Point]:

    positions = {}
    min_x = float("inf")
    min_y = float("inf")
    max_x = float("-inf")
    max_y = float("-inf")
    for k, v in graph.nodes(data=True):
        if v is None:
            raise ValueError("Graph has no attributes")
        v["pos"] = v["pos"].replace('"', "")
        m = POSITIONS.match(v["pos"])

        if m is None:
            raise ValueError("Invalid position format")

        x = float(m.group(1))
        y = float(m.group(2))

        positions[k] = (x, y)
        min_x = min(min_x, x)
        min_y = min(min_y, y)
        max_x = max(max_x, x)
        max_y = max(max_y, y)

    return positions, Point(min_x, min_y), Point(max_x, max_y)


def get_labels(graph: nx.Graph) -> dict[Any, str]:
    return {k: f"{k}\n{v}" for k, v in nx.get_node_attributes(graph, "label").items()}


def get_negative_cycle(g: nx.DiGraph) -> Optional[list[Any]]:
    n = len(g.nodes())
    d = defaultdict(lambda: 1000_000_000)
    p = defaultdict(lambda: -1)
    x = -1

    for _ in range(n):
        for u, v, data in cast(tuple[Any, Any, dict], g.edges(data=True)):
            weight = data["weight"]
            if d[u] + weight < d[v]:
                d[v] = d[u] + weight
                p[v] = u
                x = v

    if x == -1:
        print("No negative cycle")
        return None
    for _ in range(n):
        x = p[x]
    cycle = []
    v = x
    while True:
        cycle.append(v)
        if v == x and len(cycle) > 1:
            break
        v = p[v]
    return list(reversed(cycle))


def get_cycle_weight(g: nx.Graph, cycle: list[Any]) -> float:
    weight = 0
    for i in range(len(cycle) - 1):
        weight += float(g[cycle[i]][cycle[i + 1]]["weight"])
    return weight


def get_cycle_edges(g: nx.Graph, cycle: list[Any]) -> list[Edge]:
    return [(cycle[i], cycle[i + 1]) for i in range(len(cycle) - 1)]


def save_as_dot(
    graph: nx.Graph, filename: Path | str, highlight: Optional[Iterable[Edge]] = None
) -> None:
    if highlight is None:
        highlight = set()
    else:
        highlight = set(highlight)

    g_copy = graph.copy()
    g_copy.graph["layout"] = "neato"
    if False:
        nx.set_node_attributes(g_copy, {k: f"{2*v[0]},{4*v[1]}!" for k, v in pos.items()}, "pos")
        labels = get_labels(g_copy)
        nx.set_node_attributes(
            g_copy, {k: v.replace("\n", "\\n") for k, v in labels.items()}, "label"
        )
        nx.set_node_attributes(g_copy, True, "pin")
    weights = nx.get_edge_attributes(g_copy, "weight")
    nx.set_edge_attributes(g_copy, weights, "label")

    # Remove node attributes
    for _, d in g_copy.nodes(data=True):
        if d is None:
            continue
        for v in ["job", "op"]:
            if v in d:
                d.pop(v)

    for _, _2, d in cast(Iterable[tuple[Any, Any, Optional[dict]]], g_copy.edges(data=True)):
        if d is None:
            continue
        for v in ["color"]:
            if v in d:
                d.pop(v)

    for src, dst in highlight:
        g_copy[src][dst]["color"] = "red"
    nx.nx_agraph.write_dot(g_copy, filename)
